# ----------------------------------------------------------------------------------------------------------------------------- #
# ____                                      __          __  __          ___                                                     #
#/\  _ `.                                  /\ \        /\ \/\ \        /\_ \                                                    #
#\ \ \/\ \  _ __    __     __      ___ ___ \ \/ ____   \ \ \_\ \    ___\//\ \     ___      __   _ __    __      ___ ___         #
# \ \ \ \ \/\`'__\/'__`\ /'__`\  /' __` __`\\/ /',__\   \ \  _  \  / __`\\ \ \   / __`\  /'_ `\/\`'__\/'__`\  /' __` __`\       #
#  \ \ \_\ \ \ \//\  __//\ \ \.\_/\ \/\ \/\ \ /\__, `\   \ \ \ \ \/\ \ \ \\_\ \_/\ \ \ \/\ \ \ \ \ \//\ \ \.\_/\ \/\ \/\ \      #
#   \ \____/\ \_\\ \____\ \__/.\_\ \_\ \_\ \_\\/\____/    \ \_\ \_\ \____//\____\ \____/\ \____ \ \_\\ \__/.\_\ \_\ \_\ \_\     #
#    \/___/  \/_/ \/____/\/__/\/_/\/_/\/_/\/_/ \/___/      \/_/\/_/\/___/ \/____/\/___/  \/___ \ \/_/ \/__/\/_/\/_/\/_/\/_/     #
#                                                                                          /\____/                              #
#                                                                                          \_/__/                               #
# ----------------------------------------------------------------------------------------------------------------------------- #
# Modeler Version: v5.1
# Date: 12/25/2018 @ 2146
# Holograms: 68
# Notes: 
# --------------------------------------------- #
@name mech8_new
@persist Hologram:table [ Seat Driver Entity ]:entity
@persist [ SPEED SHIFTSPEED LEGSPEED STEPDAMP STEPARCH LEGINCREMENT BODYHEIGHT CANJUMP STATE LaserIndex ]:number
@persist [ RRR_P1 RRR_P2 RRR_P3 ]:vector [ RRR_STEP RRR_DIST ]:number
@persist [ RRC_P1 RRC_P2 RRC_P3 ]:vector [ RRC_STEP RRC_DIST ]:number
@persist [ FRC_P1 FRC_P2 FRC_P3 ]:vector [ FRC_STEP FRC_DIST ]:number
@persist [ FRF_P1 FRF_P2 FRF_P3 ]:vector [ FRF_STEP FRF_DIST ]:number
@persist [ RLR_P1 RLR_P2 RLR_P3 ]:vector [ RLR_STEP RLR_DIST ]:number
@persist [ RLC_P1 RLC_P2 RLC_P3 ]:vector [ RLC_STEP RLC_DIST ]:number
@persist [ FLC_P1 FLC_P2 FLC_P3 ]:vector [ FLC_STEP FLC_DIST ]:number
@persist [ FLF_P1 FLF_P2 FLF_P3 ]:vector [ FLF_STEP FLF_DIST ]:number
@model models/sprops/cuboids/height24/size_3/cube_48x48x24.mdl
if( first( ) ) {
    
    SPEED = 70
    SHIFTSPEED = 70
    LEGSPEED = 0.65
    STEPDAMP = 2
    STEPARCH = 2.5
    LEGINCREMENT = 0.05
    BODYHEIGHT = 90
    
    Entity = entity( )
    Entity:setMass( 50000 )
    Entity:propGravity( 0 )
    propSpawnUndo( 0 )
    
    function void async( T, F:string ) { 
        timer( format( "cb:%.0f:%s:null:%s", randint( 1e15 ), F, vonEncode( array( ) ) ),   T * 1000 )
    }
    
    function ranger visibleRanger( A, B, C, From:vector, To:vector ) {
        local XRD = rangerOffset( From, To )
        holoPos( A, From )
        holoPos( B, ( XRD:position( ) + From ) / 2 )
        holoAng( B, ( XRD:position( ) - From ):toAngle( ) )
        holoScaleUnits( B, vec( XRD:distance( ), 1, 1 ) )
        holoPos( C, XRD:position( ) )
        return XRD
    }
    
    
    Hologram = table()
    Hologram[ "model", array ] = array("models/holograms/cube.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/holograms/hq_sphere.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl","models/holograms/hq_sphere.mdl","models/holograms/cube.mdl","models/holograms/hq_tube_thin.mdl","models/holograms/hq_cylinder.mdl","models/holograms/hq_tube.mdl","models/holograms/hq_tube.mdl","models/holograms/hq_tube.mdl","models/holograms/hq_tube.mdl","models/holograms/hq_tube.mdl","models/holograms/hq_cylinder.mdl","models/props_lab/tpplug.mdl","models/props_lab/tpplug.mdl","models/items/combine_rifle_ammo01.mdl","models/items/combine_rifle_ammo01.mdl")
    Hologram[ "position", array ] = array(vec(0,0,72.5),vec(42,0,72.5),vec(-24.5,0,72.5),vec(-24.5,0,72.5),vec(-11,-17.4023,72.5),vec(-17.1006,-31.1055,72.5),vec(-17.1006,-31.1055,172.5),vec(-17.1006,-31.1055,272.5),vec(-17.1006,-31.1055,372.5),vec(-17.1006,-31.1055,72.5),vec(-17.1006,-31.1055,172.5),vec(-17.1006,-31.1055,272.5),vec(4.5,-22.5,72.5),vec(2.4121,-37.3535,72.5),vec(2.4121,-37.3535,172.5),vec(2.4121,-37.3535,272.5),vec(2.4121,-37.3535,372.5),vec(2.4121,-37.3535,72.5),vec(2.4121,-37.3535,172.5),vec(2.4121,-37.3535,272.5),vec(18.5,-23,72.5),vec(21.3623,-37.7246,72.5),vec(21.3623,-37.7246,172.5),vec(21.3623,-37.7246,272.5),vec(21.3623,-37.7246,372.5),vec(21.3623,-37.7246,72.5),vec(21.3623,-37.7246,172.5),vec(21.3623,-37.7246,272.5),vec(33.5,-18.5,72.5),vec(39.4814,-32.2559,72.5),vec(39.4814,-32.2559,172.5),vec(39.4814,-32.2559,272.5),vec(39.4814,-32.2559,372.5),vec(39.4814,-32.2559,72.5),vec(39.4814,-32.2559,172.5),vec(39.4814,-32.2559,272.5),vec(-11,17.3994,72.5),vec(-19.3877,29.835,72.5),vec(-19.3877,29.835,172.5),vec(-19.3877,29.835,272.5),vec(-19.3877,29.835,372.5),vec(-19.3877,29.835,72.5),vec(-19.3877,29.835,172.5),vec(-19.3877,29.835,272.5),vec(4.5,22.5,72.5),vec(2.4121,37.3535,72.5),vec(2.4121,37.3535,172.5),vec(2.4121,37.3535,272.5),vec(2.4121,37.3535,372.5),vec(2.4121,37.3535,72.5),vec(2.4121,37.3535,172.5),vec(2.4121,37.3535,272.5),vec(18.5,23,72.5),vec(21.3623,37.7246,72.5),vec(21.3623,37.7246,172.5),vec(21.3623,37.7246,272.5),vec(21.3623,37.7246,372.5),vec(21.3623,37.7246,72.5),vec(21.3623,37.7246,172.5),vec(21.3623,37.7246,272.5),vec(33.5,18.5,72.5),vec(39.4814,32.2559,72.5),vec(39.4814,32.2559,172.5),vec(39.4814,32.2559,272.5),vec(39.4814,32.2559,372.5),vec(39.4814,32.2559,72.5),vec(39.4814,32.2559,172.5),vec(39.4814,32.2559,272.5),vec(-65,0,116.5),vec(-65,0,152),vec(-65,0,157.5),vec(-65,0,157.5),vec(-41,0,157.5),vec(-43,0,157.5),vec(-47.5,0,157.5),vec(17,0,50),vec(-47,0,157.5),vec(-47,0,157.5),vec(-82.5,0,157.5),vec(-89.5,0,157.5),vec(-42.5,0,157),vec(-44.5,0,157.5),vec(-88.0981,0,157.5))
    Hologram[ "angle", array ] = array(ang(0,0,0),ang(90,0,0),ang(90,0,0),ang(-90,0,0),ang(0,-24,90),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,-8,90),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,11,90),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,23.5,90),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,34,-90),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,8,-90),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,-11,-90),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,-23.5,-90),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(0,0,0),ang(90,0,0),ang(90,0,0),ang(90,0,0),ang(90,0,0),ang(90,0,0),ang(90,0,0),ang(90,0,0),ang(90,0,0),ang(0,0,0),ang(0,-180,-180),ang(90,0,0),ang(90,0,0))
    Hologram[ "scale", array ] = array(vec(1,1,1),vec(10,10,5),vec(8,8,6),vec(17,17,10),vec(3,3,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,8.4),vec(3,3,3),vec(1,1,1),vec(0.1,0.1,0.1),vec(1,1,4),vec(0.3,0.3,0.001),vec(0.4,0.4,0.4),vec(0.9,0.9,1),vec(0.7,0.7,1),vec(0.55,0.55,1),vec(0.5,0.5,1),vec(1,1,1),vec(1,1,1),vec(1,1,1),vec(1.5,1.5,0.1),vec(3,3,4))
    Hologram[ "color", array ] = array(vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(0,0,0),vec(255,255,255),vec(0,0,0),vec(255,255,255),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(0,0,0),vec(255,255,255),vec(255,255,255),vec(255,255,255),vec(255,255,255))
    Hologram[ "alpha", array ] = array(255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,50,255,255,255,255,255,255,255,255,255,255)
    Hologram[ "material", array ] = array("","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","")
    Hologram[ "parent", array ] = array(1,1,1,1,1,5,6,7,8,6,7,8,1,13,14,15,16,14,15,16,1,21,22,23,24,22,23,24,1,29,30,31,32,30,31,32,1,37,38,39,40,38,39,40,1,45,46,47,48,46,47,48,1,53,54,55,56,54,55,56,1,61,62,63,64,62,63,64,1,1,1,71,71,71,71,76,71,71,71,71,71,71,71)
    
    for( I = 1001, 1024 ) {
        holoCreate(I)
    }
    
    #ik relative workaround..
    for( I = 2001, 2008 ) {
        holoCreate( 
            I,
            entity():toWorld( Hologram[ "position", array ][ select( I - 2000, 6, 14, 22, 30, 38, 46, 54, 62 ), vector ] ),
            vec(1)
        )      
    }
    
    function buffer( ) {
        local Next = Hologram[ "next", number ]
        for( I = Next, Next + clamp( holoRemainingSpawns( ), 0, Hologram[ "model", array ]:count( ) - Next + 1 ) ) {
            holoCreate(
                I,
                Entity:toWorld(Hologram["position", array][I, vector]),
                Hologram["scale", array][I, vector],
                Entity:toWorld(Hologram["angle", array][I, angle]),
                vec4(Hologram["color", array][I, vector],
                Hologram["alpha", array ][I,number]),
                Hologram["model", array][I, string]
            )
            holoMaterial(I, Hologram["material", array][I, string])
            holoParent(I, Hologram["parent", array][I, number])
            Hologram[ "next", number ] = I
        }
        if( Next <= Hologram[ "model", array ]:count( ) ) { timer( "buffer", 0.1 )
        } else {
            rangerHitEntities( 1 )
            hint( "Dream's Mech ready for use!", 7 )
            for( I = 2001, 2008 ) {
                holoParent( I, 1 )
            }
            Seat = seatSpawn( "models/nova/airboat_seat.mdl", holoEntity( 1 ):toWorld( vec( 0, 0, 30 ) ), Entity:angles( ) - ang( 0, 90, 0 ), 0 )
            Seat:parentTo( holoEntity( 1 ) )
            Seat:setAlpha( 255 )
            Seat:propFreeze( 0 )
            holoParent( 1, Entity )
            holoPos( 1, Entity:pos( ) )
            Entity:setPos( Entity:toWorld( vec( 0, 0, BODYHEIGHT ) ) )
            Entity:propFreeze( 0 )
            #owner():plyEnterVehicle( Seat )
            runOnTick( 1 )
        }
    } buffer( )
    
    function entity:ik3c( A, B, C, LengthA, LengthB, Destination:vector ) {
        Distance = holoEntity( A ):pos():distance( Destination )
        Ae = max( Distance, LengthB )
        Be = LengthA
        Ce = min( Distance, LengthB )
        Calc = sqrt( ( (Ae + Be - Ce + Be) * (-Ae + Be + Ce + Be) * (Ae - Be - Ce + Be) * (Ae + Be - Ce - Be) ) / ( 4 * (Ae - Ce) ^ 2 ) )
        local Arcs = ( sign( Distance - LengthA ) + 1 ) / 2 ? asin( Calc / LengthA ) : acos( Calc / LengthA ) + 90
        holoAng( A, This:toWorld( ang( 0, -This:bearing( Destination ) - 90, This:elevation( Destination ) + Arcs - 90 ) ) )
        holoAng( B, holoEntity( A ):toWorld( ang( 0, 0, -Arcs ) ) )
        holoAng( C, holoEntity( B ):toWorld( ang( 0, 0, -Arcs ) ) )
    }
    
    local TOffset = LEGSPEED / 8
    
    function rrr() {
        local V = Entity:vel( ):normalized( ) * clamp( Entity:vel():length(), 0, 400 ) 
        local XRD = rangerOffset( Entity:toWorld( vec( -155, -145, 250 ) / 2 ), Entity:toWorld( vec( -155, -145, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        if( !XRD:hit() ) {
            #XRD = visibleRanger( 1001, 1002, 1003, Entity:toWorld( vec( -155, -145, 0 ) ), Entity:toWorld( vec( 0, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
            XRD = rangerOffset( Entity:toWorld( vec( -155, -145, 0 ) ), Entity:toWorld( vec( -155, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
        }
        #local XRD = visibleRanger( 1001, 1002, 1003, Entity:toWorld( vec( -155, -145, 250 ) / 2 ), Entity:toWorld( vec( -155, -145, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        RRR_P1 = holoEntity( 9 ):pos( )
        RRR_P3 = XRD:position( )
        RRR_P2 = ( RRR_P1 + RRR_P3 ) * 0.5 + Entity:up() * RRR_P1:distance( RRR_P3 ) / STEPARCH
        RRR_STEP = 0
        RRR_DIST = XRD:distance()
        async( LEGSPEED, "rrr" )
    } async( TOffset * 0, "rrr" )
    
    function rrc() {
        local V = Entity:vel( ):normalized( ) * clamp( Entity:vel():length(), 0, 400 ) 
        local XRD = rangerOffset( Entity:toWorld( vec( -50, -195, 250 ) / 2 ), Entity:toWorld( vec( -50, -195, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        if( !XRD:hit() ) {
            #XRD = visibleRanger( 1001, 1002, 1003, Entity:toWorld( vec( -50, -195, 0 ) ), Entity:toWorld( vec( 0, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
            XRD = rangerOffset( Entity:toWorld( vec( -50, -195, 0 ) ), Entity:toWorld( vec( -50, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
        }
        #local XRD = visibleRanger( 1004, 1005, 1006, Entity:toWorld( vec( -50, -195, 250 ) / 2 ), Entity:toWorld( vec( -50, -195, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        RRC_P1 = holoEntity( 17 ):pos( )
        RRC_P3 = XRD:position( )
        RRC_P2 = ( RRC_P1 + RRC_P3 ) * 0.5 + Entity:up() * RRC_P1:distance( RRC_P3 ) / STEPARCH
        RRC_STEP = 0
        RRC_DIST = XRD:distance()
        async( LEGSPEED, "rrc" )
    } async( TOffset * 4, "rrc" )
    
    function frc() {
        local V = Entity:vel( ):normalized( ) * clamp( Entity:vel():length(), 0, 400 )
        local XRD = rangerOffset( Entity:toWorld( vec( 50, -195, 250 ) / 2 ), Entity:toWorld( vec( 50, -195, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        if( !XRD:hit() ) {
            #XRD = visibleRanger( 1001, 1002, 1003, Entity:toWorld( vec( 50, -195, 0 ) ), Entity:toWorld( vec( 0, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
            XRD = rangerOffset( Entity:toWorld( vec( 50, -195, 0 ) ), Entity:toWorld( vec( 50, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
        }
        #local XRD = visibleRanger( 1007, 1008, 1009, Entity:toWorld( vec( 50, -195, 250 ) / 2 ), Entity:toWorld( vec( 50, -195, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        FRC_P1 = holoEntity( 25 ):pos( )
        FRC_P3 = XRD:position( )
        FRC_P2 = ( FRC_P1 + FRC_P3 ) * 0.5 + Entity:up() * FRC_P1:distance( FRC_P3 ) / STEPARCH
        FRC_STEP = 0
        FRC_DIST = XRD:distance()
        async( LEGSPEED, "frc" )
    } async( TOffset * 2, "frc" )
    
    function frf() {
        local V = Entity:vel( ):normalized( ) * clamp( Entity:vel():length(), 0, 400 )
        local XRD = rangerOffset( Entity:toWorld( vec( 155, -145, 250 ) / 2 ), Entity:toWorld( vec( 155, -145, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        if( !XRD:hit() ) {
            #XRD = visibleRanger( 1001, 1002, 1003, Entity:toWorld( vec( 155, -145, 0 ) ), Entity:toWorld( vec( 0, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
            XRD = rangerOffset( Entity:toWorld( vec( 155, -145, 0 ) ), Entity:toWorld( vec( 155, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
        }
        #local XRD = visibleRanger( 1010, 1011, 1012, Entity:toWorld( vec( 155, -145, 250 ) / 2 ), Entity:toWorld( vec( 155, -145, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        FRF_P1 = holoEntity( 33 ):pos( )
        FRF_P3 = XRD:position( )
        FRF_P2 = ( FRF_P1 + FRF_P3 ) * 0.5 + Entity:up() * FRF_P1:distance( FRF_P3 ) / STEPARCH
        FRF_STEP = 0
        FRF_DIST = XRD:distance()
        async( LEGSPEED, "frf" )
    } async( TOffset * 6, "frf" )
    
    function rlr() {
        local V = Entity:vel( ):normalized( ) * clamp( Entity:vel():length(), 0, 400 )
        local XRD = rangerOffset( Entity:toWorld( vec( -155, 145, 250 ) / 2 ), Entity:toWorld( vec( -155, 145, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        if( !XRD:hit() ) {
            #XRD = visibleRanger( 1001, 1002, 1003, Entity:toWorld( vec( -155, 145, 0 ) ), Entity:toWorld( vec( 0, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
            XRD = rangerOffset( Entity:toWorld( vec( -155, 145, 0 ) ), Entity:toWorld( vec( -155, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
        }
        #local XRD = visibleRanger( 1013, 1014, 1015, Entity:toWorld( vec( -155, 145, 250 ) / 2 ), Entity:toWorld( vec( -155, 145, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        RLR_P1 = holoEntity( 41 ):pos( )
        RLR_P3 = XRD:position( )
        RLR_P2 = ( RLR_P1 + RLR_P3 ) * 0.5 + Entity:up() * RLR_P1:distance( RLR_P3 ) / STEPARCH
        RLR_STEP = 0
        RLR_DIST = XRD:distance()
        async( LEGSPEED, "rlr" )
    } async( TOffset * 4, "rlr" )
    
    function rlc() {
        local V = Entity:vel( ):normalized( ) * clamp( Entity:vel():length(), 0, 400 )
        local XRD = rangerOffset( Entity:toWorld( vec( -50, 195, 250 ) / 2 ), Entity:toWorld( vec( -50, 195, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        if( !XRD:hit() ) {
            #XRD = visibleRanger( 1001, 1002, 1003, Entity:toWorld( vec( -50, 195, 0 ) ), Entity:toWorld( vec( 0, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
            XRD = rangerOffset( Entity:toWorld( vec( -50, 195, 0 ) ), Entity:toWorld( vec( -50, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
        }
        #local XRD = visibleRanger( 1016, 1017, 1018, Entity:toWorld( vec( -50, 195, 250 ) / 2 ), Entity:toWorld( vec( -50, 195, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        RLC_P1 = holoEntity( 49 ):pos( )
        RLC_P3 = XRD:position( )
        RLC_P2 = ( RLC_P1 + RLC_P3 ) * 0.5 + Entity:up() * RLC_P1:distance( RLC_P3 ) / STEPARCH
        RLC_STEP = 0
        RLC_DIST = XRD:distance()
        async( LEGSPEED, "rlc" )
    } async( TOffset * 0, "rlc" )
    
    function flc() {
        local V = Entity:vel( ):normalized( ) * clamp( Entity:vel():length(), 0, 400 )
        local XRD = rangerOffset( Entity:toWorld( vec( 50, 195, 250 ) / 2 ), Entity:toWorld( vec( 50, 195, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        if( !XRD:hit() ) {
            #XRD = visibleRanger( 1001, 1002, 1003, Entity:toWorld( vec( 50, 195, 0 ) ), Entity:toWorld( vec( 0, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
            XRD = rangerOffset( Entity:toWorld( vec( 50, 195, 0 ) ), Entity:toWorld( vec( 50, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
        }
        #local XRD = visibleRanger( 1019, 1020, 1021, Entity:toWorld( vec( 50, 195, 250 ) / 2 ), Entity:toWorld( vec( 50, 195, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        FLC_P1 = holoEntity( 57 ):pos( )
        FLC_P3 = XRD:position( )
        FLC_P2 = ( FLC_P1 + FLC_P3 ) * 0.5 + Entity:up() * FLC_P1:distance( FLC_P3 ) / STEPARCH
        FLC_STEP = 0
        FLC_DIST = XRD:distance()
        async( LEGSPEED, "flc" )
    } async( TOffset * 6, "flc" )
    
    function flf() {
        local V = Entity:vel( ):normalized( ) * clamp( Entity:vel():length(), 0, 400 )
        local XRD = rangerOffset( Entity:toWorld( vec( 155, 145, 250 ) / 2 ), Entity:toWorld( vec( 155, 145, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        if( !XRD:hit() ) {
            #XRD = visibleRanger( 1001, 1002, 1003, Entity:toWorld( vec( 155, 145, 0 ) ), Entity:toWorld( vec( 0, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
            XRD = rangerOffset( Entity:toWorld( vec( 155, 145, 0 ) ), Entity:toWorld( vec( 155, 0, -BODYHEIGHT * 3 ) ) + V / STEPDAMP )
        }
        #local XRD = visibleRanger( 1022, 1023, 1024, Entity:toWorld( vec( 155, 145, 250 ) / 2 ), Entity:toWorld( vec( 155, 145, -BODYHEIGHT * 2 ) ) + V / STEPDAMP )
        FLF_P1 = holoEntity( 65 ):pos( )
        FLF_P3 = XRD:position( )
        FLF_P2 = ( FLF_P1 + FLF_P3 ) * 0.5 + Entity:up() * FLF_P1:distance( FLF_P3 ) / STEPARCH
        FLF_STEP = 0
        FLF_DIST = XRD:distance()
        async( LEGSPEED, "flf" )
    } async( TOffset * 2, "flf" )
}

if( clk( "buffer" ) ) { buffer( ) } elseif( tickClk( ) ) {
    
    Driver = Seat:driver( )
    
    LegLen = 100
    
    RRR_STEP = clamp( RRR_STEP + LEGINCREMENT, 0, 1 )
    holoEntity( 2001 ):ik3c( 6, 7, 8, LegLen, LegLen, bezier( RRR_P1, RRR_P2, RRR_P3, RRR_STEP ) )
    RRC_STEP = clamp( RRC_STEP + LEGINCREMENT, 0, 1 )
    holoEntity( 2002 ):ik3c( 14, 15, 16, LegLen, LegLen, bezier( RRC_P1, RRC_P2, RRC_P3, RRC_STEP ) )
    FRC_STEP = clamp( FRC_STEP + LEGINCREMENT, 0, 1 )
    holoEntity( 2003 ):ik3c( 22, 23, 24, LegLen, LegLen, bezier( FRC_P1, FRC_P2, FRC_P3, FRC_STEP ) )
    FRF_STEP = clamp( FRF_STEP + LEGINCREMENT, 0, 1 )
    holoEntity( 2004 ):ik3c( 30, 31, 32, LegLen, LegLen, bezier( FRF_P1, FRF_P2, FRF_P3, FRF_STEP ) )
    RLR_STEP = clamp( RLR_STEP + LEGINCREMENT, 0, 1 )
    holoEntity( 2005 ):ik3c( 38, 39, 40, LegLen, LegLen, bezier( RLR_P1, RLR_P2, RLR_P3, RLR_STEP ) )
    RLC_STEP = clamp( RLC_STEP + LEGINCREMENT, 0, 1 )
    holoEntity( 2006 ):ik3c( 46, 47, 48, LegLen, LegLen, bezier( RLC_P1, RLC_P2, RLC_P3, RLC_STEP ) )
    FLC_STEP = clamp( FLC_STEP + LEGINCREMENT, 0, 1 )
    holoEntity( 2007 ):ik3c( 54, 55, 56, LegLen, LegLen, bezier( FLC_P1, FLC_P2, FLC_P3, FLC_STEP ) )
    FLF_STEP = clamp( FLF_STEP + LEGINCREMENT, 0, 1 )
    holoEntity( 2008 ):ik3c( 62, 63, 64, LegLen, LegLen, bezier( FLF_P1, FLF_P2, FLF_P3, FLF_STEP ) )
    
    local Torque = vec(
        ( FRC_DIST + RRC_DIST ) / 2 - ( RLC_DIST + FLC_DIST ) / 2,
        ( FRF_DIST + FLF_DIST ) / 2 - ( RRR_DIST + RLR_DIST ) / 2,
        ( Driver:keyAttack1() - Driver:keyAttack2() ) * 100
    )
    
    Entity:applyTorque( Entity:inertia() * ( Torque * 15 - Entity:angVelVector() * 27.05 ) )
    #Entity:setAng( shiftL( Torque ):toAngle() )
    
    local Controls = vec( 
        Driver:keyForward( ) - Driver:keyBack( ), 
        Driver:keyLeft( )    - Driver:keyRight( ), 
        Driver:keyJump( )    - Driver:keyWalk( )
    ):rotate( Entity:angles() )
    
    local LegMid = ( RRR_P3 + RRC_P3 + FRC_P3 + FRF_P3 + RLR_P3 + RLC_P3 + FLC_P3 + FLF_P3 ) / 8
    local Vec = shiftL( Torque ):toAngle():up() * ( BODYHEIGHT - LegMid:distance( Entity:pos() ) )
    
    local Mid = ( LegMid + ( Entity:up() * BODYHEIGHT ) - Entity:pos() )
    local XRD = rangerOffset( Entity:pos(), Entity:toWorld( vec( 0, 0, -BODYHEIGHT ) ) )
    if( XRD:hit() ) {
        Mid = ( XRD:position() + ( Entity:up() * BODYHEIGHT * 1.5 ) - Entity:pos() )
    }
    local Speed = Driver:keySprint() ? SHIFTSPEED : SPEED
    Entity:applyForce( Controls * Speed * Entity:mass() + Mid * Entity:mass() - Entity:mass() * Entity:vel() / 2 )
}

if( clkName( ) != "" && !clk( ) ) {
    local Match = clkName( ):match( "^cb:%d+:([^:]+):([%a%d]+):(.*)$" )
    if( Match:count( ) == 3){
        local F = Match[ 1, string ]
        local R = vonDecode( Match[ 3, string ] )
        switch( Match[ 2, string ] ) {
            case "null", F( ), break
        }
        exit()
    }
}



